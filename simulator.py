"""
File for simulation of the quadrotor in a given environment. This file is used for tracking:
    - A path generated by RRT_star
    - Converted into a trajectory by means of cubic spline interpolation or minimum snap
    - Tracked by means of a geometric non-linear controller
"""
import numpy as np
from simulator_helpers import generate_env, plot_all, init_simulation, find_closest
from RRT_3D.RRT_star_plotter import RRT_star
from traj_optimization.cubic_spline import cubic_spline
from traj_optimization.mini_snap_optim import min_snap_optimizer_3d
from scipy import interpolate

####################################################################################
use_pre_saved_traj = False   # whether to generate new trajectory using RRT* and smoothing or use a precomputed one
RRT_iterations = 2000       # Number of iterations of the RRT_star algorithm
min_snap = True             # Set to True is minimum snap is to be used as interpolation or cubic splines is preferred
time_optimal = True         # When set to True, the minimum snap will be applied in a time-optimization fashion
traj_total_time = 10        # When using minimum snap and time_optimal is False, set the completion time of the path
check_collision = True      # When set to True, the minimum snap will check for collision avoidance with the obstacles
act_constr = False          # When set to True, actuator constraints will be explicitly accounted for in minimum snap
penalty = 2500              # Time penalty value of the minimum snap optimization, will be capped if act_constr is False
slow_factor = 1             # Only required for comparison with the MPC with obstacle avoidance
scenario = 0                # Scenario to test the algorithm on
####################################################################################

if __name__ == "__main__":
    # Create the quadrotor class, controller and other initial values
    env, policy, t, time_step, total_SE, total_energy, _ = init_simulation(mpc=False)

    # Define the obstacles, plotting figure and axis and other scenario properties
    obstacles, fig, ax1, map_boundary, starts, ends = generate_env(scenario)

    # global path planning using RRT*
    x_start = starts[0]
    x_goal = ends[0]
    if not use_pre_saved_traj:
        RRT = RRT_star(x_start, RRT_iterations, obstacles)
        path_exists = RRT.find_path(x_goal, map_boundary)
    else:
        path_exists = True

    # Reset the quadrotor object to the initial position
    current_state = env.reset(position=x_start)

    # Track the number of collisions just to make sure
    num_collision = 0

    # If a path has been found, proceed to follow it
    if not path_exists:
        print("No path was found for the given number of iterations")
    else:
        print("Path found, applying smoothing.")

        if not use_pre_saved_traj:
            # Apply the path interpolation algorithm selected, the path is simplified to make if time-feasible
            path_list = RRT.get_straight_path()
            if min_snap:
                # Parameters can be adjusted as necessary
                pos, vel, acc, jerk, snap, ts = min_snap_optimizer_3d(path_list, penalty=penalty, act_const=act_constr,
                                                                      time_optimal=time_optimal, obstacles=obstacles,
                                                                      check_collision=check_collision,
                                                                      total_time=traj_total_time)
            else:
                pos, vel, acc = cubic_spline(path_list, T=traj_total_time)

        else:
            # load the pre-saved trajectory
            traj = np.load('traj.npz')
            path_list = traj['path_list']
            pos = traj['pos']
            vel = traj['vel']
            acc = traj['acc']

        # Plot the initial point (may don't need it)
        ax1.plot(pos[:, 0], pos[:, 1], pos[:, 2], c='mediumorchid', linewidth=2, label='Planned_path')
        real_trajectory = np.zeros((1, 3))
        real_orientation = np.zeros((1, 4))

        # interpolation of time-optimal trajectory
        if time_optimal and (slow_factor > 1):
            x = np.linspace(0, len(pos) - 1, len(pos))
            f_pos = interpolate.interp1d(x, pos, axis=0)
            f_vel = interpolate.interp1d(x, vel, axis=0)
            f_acc = interpolate.interp1d(x, acc, axis=0)
            x_interp = np.linspace(0, len(pos) - 1, int(slow_factor * len(pos)))
            pos = f_pos(x_interp)
            vel = f_vel(x_interp) / slow_factor
            acc = f_acc(x_interp) / slow_factor

        for i in range(len(pos)):
            closest_obstacle = find_closest(current_state, obstacles)
            if closest_obstacle <= 0:
                num_collision += 1
            state_des = {'pos': pos[i], 'vel': vel[i], 'acc': acc[i], 'yaw': 0, 'yaw_dot': 0}
            action = policy.control(state_des, current_state)
            cmd_rotor_speeds = action['cmd_rotor_speeds']
            obs, reward, done, info = env.step(cmd_rotor_speeds)
            print("current:", obs['x'])
            print('des_position: ', state_des['pos'])
            if i == 0:
                real_trajectory = np.reshape(obs['x'], (1, 3))
                real_orientation = np.reshape(obs['q'], (1, 4))
            else:
                real_trajectory = np.vstack((real_trajectory, np.reshape(obs['x'], (1, 3))))
                real_orientation = np.vstack((real_orientation, np.reshape(obs['q'], (1, 4))))
            current_state = obs
            t += time_step
            total_SE += (np.sum((obs['x'] - state_des['pos']) ** 2) * time_step)
            total_energy += (np.sum(cmd_rotor_speeds ** 2) * time_step)

        # Print the final metrics of the simulation
        print("Sum of tracking error (integration): ", total_SE)
        print("Total time: ", t)
        print("Sum of energy consumption (integration)", total_energy)
        print("Number of collisions: ", num_collision)

        # Plot everything
        plot_all(fig, ax1, obstacles, x_start, x_goal, path_list, real_trajectory, real_orientation)
